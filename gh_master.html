<html lang="en"><head><script>(function(firebaseConfig, initialAuthToken, appId) {
        window.__firebase_config = firebaseConfig;
        window.__initial_auth_token = initialAuthToken;
        window.__app_id = appId;
            })("\n{\n  \"apiKey\": \"AIzaSyCqyCcs2R2e7AegGjvFAwG98wlamtbHvZY\",\n  \"authDomain\": \"bard-frontend.firebaseapp.com\",\n  \"projectId\": \"bard-frontend\",\n  \"storageBucket\": \"bard-frontend.firebasestorage.app\",\n  \"messagingSenderId\": \"175205271074\",\n  \"appId\": \"1:175205271074:web:2b7bd4d34d33bf38e6ec7b\"\n}\n","eyJhbGciOiJSUzI1NiIsImtpZCI6IjExYjc0YTUyNzgwMDk5ZjEzNDY0MmNlZWM3ZGE4MjNkMTc4MDc2ZjIiLCJ0eXAiOiJKV1QifQ.eyJzdWIiOiJmaXJlYmFzZS1hZG1pbnNkay1mYnN2Y0BiYXJkLWZyb250ZW5kLmlhbS5nc2VydmljZWFjY291bnQuY29tIiwiYXVkIjoiaHR0cHM6Ly9pZGVudGl0eXRvb2xraXQuZ29vZ2xlYXBpcy5jb20vZ29vZ2xlLmlkZW50aXR5LmlkZW50aXR5dG9vbGtpdC52MS5JZGVudGl0eVRvb2xraXQiLCJ1aWQiOiIxMjk4NDY3ODM0ODQxNzc1MzM5MiIsImlzcyI6ImZpcmViYXNlLWFkbWluc2RrLWZic3ZjQGJhcmQtZnJvbnRlbmQuaWFtLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJjbGFpbXMiOnsiYXBwSWQiOiJjXzc5OTc1ZjMyN2RiNTRmMDFfZ2hfbWFzdGVyLmh0bWwtNjU5In0sImV4cCI6MTc2NTM3NTcxNSwiaWF0IjoxNzY1MzcyMTE1LCJhbGciOiJSUzI1NiJ9.AfItnsBfUHPqB7wXTRYUHEETEK9u-_pbIznBB_dZNIu-NyvAMcbYF_76kx2vfIeIm4m1Gs4UhTKeme9xKpbIDZIFEwCdXoBvF__lT7E9_2Xc74yCvJHQFxzP4S9ivwNg_5Y2xklAg81o-ZX-oOxMqJWk-J_kpcp9E2T_yK9pGSfaLAfu1FzDjdwWGgdkLQ1cjfq1YbrgK7I9LsI0k86j7PqtgQiUW3ZIlDyrj5EBVFx2eiVb2m0wkzsXrNgyx4osqyLlobGLiCsloCUlCcyExCjalID4eoV3ziegKbHSp5N4Zk_P-s1tIc1Uw8zQKIsdtX3X6fIBQ7B1cP5Q7xsBSQ","c_79975f327db54f01_gh_master.html-659")</script><script>'use strict';var h=typeof Object.defineProperties=="function"?Object.defineProperty:function(a,b,d){if(a==Array.prototype||a==Object.prototype)return a;a[b]=d.value;return a};function l(a){a=["object"==typeof globalThis&&globalThis,a,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var b=0;b<a.length;++b){var d=a[b];if(d&&d.Math==Math)return d}throw Error("Cannot find global object");}var n=l(this);
function p(a,b){if(b)a:{var d=n;a=a.split(".");for(var c=0;c<a.length-1;c++){var e=a[c];if(!(e in d))break a;d=d[e]}a=a[a.length-1];c=d[a];b=b(c);b!=c&&b!=null&&h(d,a,{configurable:!0,writable:!0,value:b})}}function r(a){function b(c){return a.next(c)}function d(c){return a.throw(c)}return new Promise(function(c,e){function f(g){g.done?c(g.value):Promise.resolve(g.value).then(b,d).then(f,e)}f(a.next())})}function t(a){return r(a())}
p("Object.values",function(a){return a?a:function(b){var d=[],c;for(c in b)Object.prototype.hasOwnProperty.call(b,c)&&d.push(b[c]);return d}});p("Array.prototype.includes",function(a){return a?a:function(b,d){var c=this;c instanceof String&&(c=String(c));var e=c.length;d=d||0;for(d<0&&(d=Math.max(d+e,0));d<e;d++){var f=c[d];if(f===b||Object.is(f,b))return!0}return!1}});/*

 MIT License

 Copyright (c) 2017-2023 W.Y.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

*/
function u(a,b){const d=a.style;b.backgroundColor&&(d.backgroundColor=b.backgroundColor);b.width&&(d.width=`${b.width}px`);b.height&&(d.height=`${b.height}px`);const c=b.style;c!=null&&Object.keys(c).forEach(e=>{d[e]=c[e]})};var v=(()=>{let a=0;return()=>{a+=1;return`u${`0000${(Math.random()*1679616<<0).toString(36)}`.slice(-4)}${a}`}})();function w(a){const b=[];for(let d=0,c=a.length;d<c;d++)b.push(a[d]);return b}let x=null;function y(a={}){return x?x:a.l?x=a.l:x=w(window.getComputedStyle(document.documentElement))}function z(a,b){return(a=(a.ownerDocument.defaultView||window).getComputedStyle(a).getPropertyValue(b))?parseFloat(a.replace("px","")):0}
function A(a,b={}){var d;if(!(d=b.width)){d=z(a,"border-left-width");var c=z(a,"border-right-width");d=a.clientWidth+d+c}(b=b.height)||(b=z(a,"border-top-width"),c=z(a,"border-bottom-width"),b=a.clientHeight+b+c);return{width:d,height:b}}function B(a){return new Promise((b,d)=>{const c=new Image;c.onload=()=>{c.decode().then(()=>{requestAnimationFrame(()=>b(c))})};c.onerror=d;c.crossOrigin="anonymous";c.decoding="async";c.src=a})}
function C(a){return t(function*(){return Promise.resolve().then(()=>(new XMLSerializer).serializeToString(a)).then(encodeURIComponent).then(b=>`data:image/svg+xml;charset=utf-8,${b}`)})}
function D(a,b,d){return t(function*(){const c=document.createElementNS("http://www.w3.org/2000/svg","svg"),e=document.createElementNS("http://www.w3.org/2000/svg","foreignObject");c.setAttribute("width",`${b}`);c.setAttribute("height",`${d}`);c.setAttribute("viewBox",`0 0 ${b} ${d}`);e.setAttribute("width","100%");e.setAttribute("height","100%");e.setAttribute("x","0");e.setAttribute("y","0");e.setAttribute("externalResourcesRequired","true");c.appendChild(e);e.appendChild(a);return C(c)})}
var E=(a,b)=>{if(a instanceof b)return!0;a=Object.getPrototypeOf(a);return a===null?!1:a.constructor.name===b.name||E(a,b)};function F(a,b){return y(b).map(d=>{const c=a.getPropertyValue(d),e=a.getPropertyPriority(d);return`${d}: ${c}${e?" !important":""};`}).join(" ")}
function G(a,b,d,c){a=window.getComputedStyle(a,d);var e=a.getPropertyValue("content");if(e!==""&&e!=="none"){var f=v();try{b.className=`${b.className} ${f}`}catch(k){return}e=document.createElement("style");var g=e.appendChild;d=`.${f}:${d}`;a.cssText?(c=a.getPropertyValue("content"),c=`${a.cssText} content: '${c.replace(/'|"/g,"")}';`):c=F(a,c);g.call(e,document.createTextNode(`${d}{${c}}`));b.appendChild(e)}};function H(a){return a.search(/^(data:)/)!==-1}function I(a,b,d){return t(function*(){const c=yield fetch(a,b);if(c.status===404)throw Error(`Resource "${c.url}" not found`);const e=yield c.blob();return new Promise((f,g)=>{const k=new FileReader;k.onerror=g;k.onloadend=()=>{try{f(d({o:c,result:k.result}))}catch(m){g(m)}};k.readAsDataURL(e)})})}const J={};function K(a,b,d){let c=a.replace(/\?.*/,"");d&&(c=a);/ttf|otf|eot|woff2?/i.test(c)&&(c=c.replace(/.*\//,""));return b?`[${b}]${c}`:c}
function L(a,b,d){return t(function*(){const c=K(a,b,d.C);if(J[c]!=null)return J[c];d.u&&(a+=(/\?/.test(a)?"&":"?")+(new Date).getTime());let e;try{const f=yield I(a,d.i,({o:g,result:k})=>{b||(b=g.headers.get("Content-Type")||"");return k.split(/,/)[1]});e=`data:${b};base64,${f}`}catch(f){e=d.B||""}return J[c]=e})};const M={P:"application/font-woff",R:"application/font-woff",N:"application/font-truetype",v:"application/vnd.ms-fontobject",H:"image/png",F:"image/jpeg",D:"image/jpeg",A:"image/gif",M:"image/tiff",L:"image/svg+xml",O:"image/webp"};function N(a){return(a=/\.([^./]*?)$/g.exec(a))?a[1]:""};function O(a){return t(function*(){const b=a.toDataURL();return b==="data:,"?a.cloneNode(!1):B(b)})}function aa(a,b){return t(function*(){if(a.currentSrc){var d=document.createElement("canvas");const c=d.getContext("2d");d.width=a.clientWidth;d.height=a.clientHeight;c==null||c.drawImage(a,0,0,d.width,d.height);d=d.toDataURL();return B(d)}d=a.poster;d=yield L(d,M[N(d).toLowerCase()]||"",b);return B(d)})}
function ba(a,b){return t(function*(){try{let d;if(a==null?0:(d=a.contentDocument)==null?0:d.body)return yield P(a.contentDocument.body,b,!0)}catch(d){}return a.cloneNode(!1)})}function ca(a,b){return t(function*(){return E(a,HTMLCanvasElement)?O(a):E(a,HTMLVideoElement)?aa(a,b):E(a,HTMLIFrameElement)?ba(a,b):a.cloneNode(a.tagName!=null&&a.tagName.toUpperCase()==="SVG")})}
function da(a,b,d){return t(function*(){if(b.tagName!=null&&b.tagName.toUpperCase()==="SVG")return b;let c=[];if(a.tagName!=null&&a.tagName.toUpperCase()==="SLOT"&&a.assignedNodes)c=w(a.assignedNodes());else{let e;if(E(a,HTMLIFrameElement)&&((e=a.contentDocument)==null?0:e.body))c=w(a.contentDocument.body.childNodes);else{let f;c=w(((f=a.shadowRoot)!=null?f:a).childNodes)}}if(c.length===0||E(a,HTMLVideoElement))return b;yield c.reduce((e,f)=>e.then(()=>P(f,d)).then(g=>{g&&b.appendChild(g)}),Promise.resolve());
return b})}function ea(a,b,d){const c=b.style;if(c){var e=window.getComputedStyle(a);e.cssText?(c.cssText=e.cssText,c.transformOrigin=e.transformOrigin):y(d).forEach(f=>{let g=e.getPropertyValue(f);f==="font-size"&&g.endsWith("px")&&(g=`${Math.floor(parseFloat(g.substring(0,g.length-2)))-.1}px`);E(a,HTMLIFrameElement)&&f==="display"&&g==="inline"&&(g="block");f==="d"&&b.getAttribute("d")&&(g=`path(${b.getAttribute("d")})`);c.setProperty(f,g,e.getPropertyPriority(f))})}}
function fa(a,b){E(a,HTMLSelectElement)&&(b=Array.from(b.children).find(d=>a.value===d.getAttribute("value")))&&b.setAttribute("selected","")}
function ha(a,b){return t(function*(){var d=a.querySelectorAll?a.querySelectorAll("use"):[];if(d.length===0)return a;var c={};for(var e=0;e<d.length;e++){var f=d[e].getAttribute("xlink:href");if(f){const g=document.querySelector(f);a.querySelector(f)||!g||c[f]||(c[f]=yield P(g,b,!0))}}d=Object.values(c);if(d.length){c=document.createElementNS("http://www.w3.org/1999/xhtml","svg");c.setAttribute("xmlns","http://www.w3.org/1999/xhtml");c.style.position="absolute";c.style.width="0";c.style.height="0";
c.style.overflow="hidden";c.style.display="none";e=document.createElementNS("http://www.w3.org/1999/xhtml","defs");c.appendChild(e);for(f=0;f<d.length;f++)e.appendChild(d[f]);a.appendChild(c)}return a})}
function P(a,b,d){return t(function*(){return d||!b.filter||b.filter(a)?Promise.resolve(a).then(c=>ca(c,b)).then(c=>da(a,c,b)).then(c=>{E(c,Element)&&(ea(a,c,b),G(a,c,":before",b),G(a,c,":after",b),E(a,HTMLTextAreaElement)&&(c.textContent=a.value),E(a,HTMLInputElement)&&c.setAttribute("value",a.value),fa(a,c));return c}).then(c=>ha(c,b)):null})};const Q=/url\((['"]?)([^'"]+?)\1\)/g,ia=/url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g,ja=/src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;function ka(a){const b=[];a.replace(Q,(d,c,e)=>{b.push(e);return d});return b.filter(d=>!H(d))}
function la(a,b,d,c){return t(function*(){try{const e=d?(new URL(b,d||void 0)).toString():b;let f;f=yield L(e,M[N(b).toLowerCase()]||"",c);return a.replace(new RegExp(`(url\\(['"]?)(${b.replace(/([.*+?^${}()|\[\]\/\\])/g,"\\$1")})(['"]?\\))`,"g"),`$1${f}$3`)}catch(e){}return a})}function ma(a,{I:b}){return b?a.replace(ja,d=>{for(;;){const [c,,e]=ia.exec(d)||[],f=c,g=e;if(!g)return"";if(g===b)return`src: ${f};`}}):a}
function R(a,b,d){return t(function*(){if(a.search(Q)===-1)return a;const c=ma(a,d);return ka(c).reduce((e,f)=>e.then(g=>la(g,f,b,d)),Promise.resolve(c))})};function S(a,b,d){return t(function*(){var c;const e=(c=b.style)==null?void 0:c.getPropertyValue(a);return e?(c=yield R(e,null,d),b.style.setProperty(a,c,b.style.getPropertyPriority(a)),!0):!1})}function na(a,b){return t(function*(){(yield S("background",a,b))||(yield S("background-image",a,b));(yield S("mask",a,b))||(yield S("-webkit-mask",a,b))||(yield S("mask-image",a,b))||(yield S("-webkit-mask-image",a,b))})}
function oa(a,b){return t(function*(){const d=E(a,HTMLImageElement);if(d&&!H(a.src)||E(a,SVGImageElement)&&!H(a.href.baseVal)){var c=d?a.src:a.href.baseVal,e=yield L(c,M[N(c).toLowerCase()]||"",b);yield new Promise((f,g)=>{a.onload=f;a.onerror=b.m?(...k)=>{try{f(b.m(...k))}catch(m){g(m)}}:g;a.decode&&(a.decode=f);a.loading==="lazy"&&(a.loading="eager");d?(a.srcset="",a.src=e):a.href.baseVal=e})}})}
function pa(a,b){return t(function*(){const d=w(a.childNodes).map(c=>T(c,b));yield Promise.all(d).then(()=>a)})}function T(a,b){return t(function*(){E(a,Element)&&(yield na(a,b),yield oa(a,b),yield pa(a,b))})};const U={};function V(a){return t(function*(){var b=U[a];if(b!=null)return b;b=yield(yield fetch(a)).text();b={url:a,cssText:b};return U[a]=b})}function W(a,b){return t(function*(){let d=a.cssText;const c=/url\(["']?([^"')]+)["']?\)/g,e=(d.match(/url\([^)]+\)/g)||[]).map(f=>t(function*(){let g=f.replace(c,"$1");g.startsWith("https://")||(g=(new URL(g,a.url)).href);return I(g,b.i,({result:k})=>{d=d.replace(f,`url(${k})`);return[f,k]})}));return Promise.all(e).then(()=>d)})}
function X(a){if(a==null)return[];const b=[];a=a.replace(/(\/\*[\s\S]*?\*\/)/gi,"");for(var d=RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})","gi");;){var c=d.exec(a);if(c===null)break;b.push(c[0])}a=a.replace(d,"");d=/@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;for(c=RegExp("((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})","gi");;){let e=d.exec(a);if(e===null)if(e=c.exec(a),e===null)break;else d.lastIndex=c.lastIndex;else c.lastIndex=
d.lastIndex;b.push(e[0])}return b}
function qa(a,b){return t(function*(){const d=[],c=[];a.forEach(e=>{if("cssRules"in e)try{w(e.cssRules||[]).forEach((f,g)=>{if(f.type===CSSRule.IMPORT_RULE){let k=g+1;f=V(f.href).then(m=>W(m,b)).then(m=>X(m).forEach(q=>{try{e.insertRule(q,q.startsWith("@import")?k+=1:e.cssRules.length)}catch(Da){}})).catch(()=>{});c.push(f)}})}catch(f){const g=a.find(k=>k.href==null)||document.styleSheets[0];e.href!=null&&c.push(V(e.href).then(k=>W(k,b)).then(k=>X(k).forEach(m=>{g.insertRule(m,g.cssRules.length)})).catch(()=>
{}))}});return Promise.all(c).then(()=>{a.forEach(e=>{if("cssRules"in e)try{w(e.cssRules||[]).forEach(f=>{d.push(f)})}catch(f){}});return d})})}function ra(a){return a.filter(b=>b.type===CSSRule.FONT_FACE_RULE).filter(b=>b.style.getPropertyValue("src").search(Q)!==-1)}function sa(a,b){return t(function*(){if(a.ownerDocument==null)throw Error("Provided element is not within a Document");var d=w(a.ownerDocument.styleSheets);d=yield qa(d,b);return ra(d)})}
function ta(a){function b(c){(c.style.fontFamily||getComputedStyle(c).fontFamily).split(",").forEach(e=>{d.add(e.trim().replace(/["']/g,""))});Array.from(c.children).forEach(e=>{e instanceof HTMLElement&&b(e)})}const d=new Set;b(a);return d}function ua(a,b){return t(function*(){const d=yield sa(a,b),c=ta(a);return(yield Promise.all(d.filter(e=>c.has(e.style.fontFamily.trim().replace(/["']/g,""))).map(e=>R(e.cssText,e.parentStyleSheet?e.parentStyleSheet.href:null,b)))).join("\n")})}
function va(a,b){return t(function*(){const d=b.j!=null?b.j:b.K?null:yield ua(a,b);if(d){const c=document.createElement("style");c.appendChild(document.createTextNode(d));a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)}})};function wa(a,b={}){return t(function*(){const {width:d,height:c}=A(a,b),e=yield P(a,b,!0);yield va(e,b);yield T(e,b);u(e,b);return yield D(e,d,c)})}
function xa(a,b={}){return t(function*(){const {width:d,height:c}=A(a,b);var e=yield wa(a,b);e=yield B(e);const f=document.createElement("canvas"),g=f.getContext("2d"),k=b.G||window.devicePixelRatio||1,m=b.h||d,q=b.g||c;f.width=m*k;f.height=q*k;!b.J&&(f.width>16384||f.height>16384)&&(f.width>16384&&f.height>16384?f.width>f.height?(f.height*=16384/f.width,f.width=16384):(f.width*=16384/f.height,f.height=16384):f.width>16384?(f.height*=16384/f.width,f.width=16384):(f.width*=16384/f.height,f.height=
16384));f.style.width=`${m}`;f.style.height=`${q}`;b.backgroundColor&&(g.fillStyle=b.backgroundColor,g.fillRect(0,0,f.width,f.height));g.drawImage(e,0,0,f.width,f.height);return f})}function ya(a,b={}){return t(function*(){return(yield xa(a,b)).toDataURL()})};const za=["gemini.google.com","corp.google.com","proxy.googlers.com"];function Y(){return document.body.querySelectorAll('[class*="animate"]').length>0}function Z(a){return t(function*(){try{return yield ya(a,{h:a.offsetWidth,g:a.offsetHeight})}catch(d){var b=a.offsetHeight;const c=document.createElement("canvas");c.width=a.offsetWidth;c.height=b;return c.toDataURL("image/png")}})}
function Aa(){return t(function*(){const a=document.body.offsetWidth,b=document.body.offsetHeight,d=document.body.cloneNode(!0);d.querySelectorAll('[class*="animate"]').forEach(c=>{c.classList.remove(...Array.from(c.classList).filter(e=>e.startsWith("animate")))});d.style.width=`${a}px`;d.style.height=`${b}px`;return d})}
function Ba(a){return t(function*(){let b=document.body;if(Y()){var d=yield Aa();b=d;document.body.appendChild(d)}d=yield Z(b);Y()&&document.body.removeChild(b);window.parent.postMessage({type:"SEND_SCREENSHOT",image:d,topOffset:document.documentElement.scrollTop},a.origin)})}function Ca(a){return t(function*(){const b={type:"SEND_SCREENSHOT_FOR_DATA_VISUALIZATION",image:yield Z(document.body),topOffset:0};window.parent.postMessage(b,a.origin)})}
window.addEventListener("message",a=>t(function*(){if(za.some(d=>a.origin.includes(d))){var b=a.data;b&&(b.type==="MAKE_SCREENSHOT"&&(yield Ba(a)),b.type==="MAKE_SCREENSHOT_FOR_DATA_VISUALIZATION"&&(yield Ca(a)))}}));
</script><script>(function() {
  // Ensure this script is executed only once
  if (window.firebaseAuthBridgeScriptLoaded) {
    return;
  }
  window.firebaseAuthBridgeScriptLoaded = true;

  let nextTokenPromiseId = 0;

  // Stores { resolve, reject } for ongoing token requests
  const pendingTokenPromises = {};

  // Listen for messages from the Host Application
  window.addEventListener('message', function(event) {

    const messageData = event.data;

  if (messageData && messageData.type === 'RESOLVE_NEW_FIREBASE_TOKEN') {
      const { success, token, error, promiseId } = messageData ?? {};
      if (pendingTokenPromises[promiseId]) {
        if (success) {
          pendingTokenPromises[promiseId].resolve(token);
        } else {
          pendingTokenPromises[promiseId].reject(new Error(error || 'Token refresh failed from host.'));
        }
        delete pendingTokenPromises[promiseId];
      }
    }
  });

  // Expose a function for the Generated App to request a new Firebase token
  window.requestNewFirebaseToken = function() {
    const currentPromiseId = nextTokenPromiseId++;
    const promise = new Promise((resolve, reject) => {
      pendingTokenPromises[currentPromiseId] = { resolve, reject };
    });
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({
        type: 'REQUEST_NEW_FIREBASE_TOKEN',
        promiseId: currentPromiseId
      }, '*');
    } else {
      pendingTokenPromises[currentPromiseId].reject(new Error('No parent window to request token from.'));
      delete pendingTokenPromises[currentPromiseId];
    }
    return promise;
  };
})();</script><script>
let realOriginalGetUserMedia = null;
if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
  realOriginalGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
}

(function() {
  if (navigator.mediaDevices && navigator.mediaDevices.__proto__) {
    try {
      Object.defineProperty(navigator.mediaDevices.__proto__, 'getUserMedia', {
        get: function() {
          return undefined; // Or throw an error
        },
        configurable: false
      });
    } catch (error) {
      console.error("Error defining prototype getter:", error);
    }
  }
})();

(function() {
  const pendingMediaResolvers = {};
  let nextMediaPromiseId = 0;

  function requestMediaPermissions(constraints) {
    const mediaPromiseId = nextMediaPromiseId++;
    const promise = new Promise((resolve, reject) => {
      pendingMediaResolvers[mediaPromiseId] = (granted) => {
        delete pendingMediaResolvers[mediaPromiseId];
        resolve(granted);
      };
    });

    window.parent.postMessage({
      type: 'requestMediaPermission',
      constraints: constraints,
      promiseId: mediaPromiseId,
    }, '*');

    return promise;
  }

  let originalGetUserMedia = realOriginalGetUserMedia;

  function interceptGetUserMedia() {
    if (navigator.mediaDevices) {
      Object.defineProperty(navigator.mediaDevices, 'getUserMedia', {
        value: function(constraints) {
          return requestMediaPermissions(constraints).then((granted) => {
            if (granted) {
              if (originalGetUserMedia) {
                return originalGetUserMedia(constraints);
              } else {
                throw new Error("Original getUserMedia not available.");
              }
            } else {
              throw new DOMException('Permission denied', 'NotAllowedError');
            }
          });
        },
        writable: false,
        configurable: false
      });
    }
  }

  interceptGetUserMedia();

  const observer = new MutationObserver(function(mutationsList, observer) {
    for (const mutation of mutationsList) {
      if (mutation.type === 'reconfigured' && mutation.name === 'getUserMedia' && mutation.object === navigator.mediaDevices) {
        interceptGetUserMedia();
      } else if (mutation.type === 'attributes' && mutation.attributeName === 'getUserMedia' && mutation.target === navigator.mediaDevices) {
        interceptGetUserMedia();
      } else if (mutation.type === 'childList' && mutation.addedNodes) {
        mutation.addedNodes.forEach(node => {
          if (node === navigator.mediaDevices) {
            interceptGetUserMedia();
          }
        });
      }
    }
  });

  function interceptSpeechRecognition() {
    if (!window.SpeechRecognition && !window.webkitSpeechRecognition) {
      return;
    }

    const OriginalSpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

    const SpeechRecognitionWrapper = function(...args) {
      const recognizer = new OriginalSpeechRecognition(...args);
      const originalStart = recognizer.start.bind(recognizer);

      recognizer.start = function() {
        requestMediaPermissions({ audio: true }).then(granted => {
          if (granted) {
            originalStart();
          } else {
            const errorEvent = new SpeechRecognitionErrorEvent('error');
            errorEvent.error = 'not-allowed'; // This is the standard error for permission denial.
            recognizer.dispatchEvent(errorEvent);
          }
        });
      };

      return recognizer;
    };

    SpeechRecognitionWrapper.prototype = OriginalSpeechRecognition.prototype;
    SpeechRecognitionWrapper.prototype.constructor = SpeechRecognitionWrapper;

    if (window.SpeechRecognition) {
      window.SpeechRecognition = SpeechRecognitionWrapper;
    }
    if (window.webkitSpeechRecognition) {
      window.webkitSpeechRecognition = SpeechRecognitionWrapper;
    }
  }

  interceptSpeechRecognition();

  window.addEventListener('message', function(event) {
    if (event.data) {
      if (event.data.type === 'resolveMediaPermission') {
        const { promiseId, granted } = event.data;
        if (pendingMediaResolvers[promiseId]) {
          pendingMediaResolvers[promiseId](granted);
        }
      }
    }
  });

})();</script><script>((function(modelInformation) {
  const originalFetch = window.fetch;
  // TODO: b/421908508 - Move these out of the script and match all generative AI model calls.
  let googleLlmBaseApiUrls = [
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':streamGenerateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predict',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predictLongRunning',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageEditModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageTransformModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predict',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predictLongRunning',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.ttsModelName + ':generateContent',
  ];
  modelInformation.deprecatedTextModelNames.forEach((modelName) => {
    googleLlmBaseApiUrls.push(
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':streamGenerateContent',
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':generateContent',
    );
  });
  modelInformation.deprecatedImageModelNames.forEach((modelName) => {
    googleLlmBaseApiUrls.push(
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':predict',
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':predictLongRunning',
    );
  });

  const pendingFetchResolvers = {};
  let nextPromiseId = 0;

  function handleStringInput(input, optionsArgument) {
    const actualUrl = input;
    const fetchCallArgs = [actualUrl, optionsArgument];
    const effectiveOptions = optionsArgument || {};
    const bodyForApiKeyCheck = effectiveOptions.body;
    const bodyForPostMessage = effectiveOptions.body;
    return { actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage };
  }

  function handleRequestInput(input, optionsArgument) {
    const actualUrl = input.url;
    const fetchCallArgs = [input, optionsArgument];
    const effectiveOptions = { method: input.method, headers: new Headers(input.headers) };
    let bodyForApiKeyCheck;
    let bodyForPostMessage;

    if (optionsArgument) {
      if (optionsArgument.method) effectiveOptions.method = optionsArgument.method;
      if (optionsArgument.headers) effectiveOptions.headers = new Headers(optionsArgument.headers);
      if ('body' in optionsArgument) {
        bodyForApiKeyCheck = optionsArgument.body;
        bodyForPostMessage = optionsArgument.body;
      } else {
        bodyForApiKeyCheck = undefined;
        bodyForPostMessage = input.body;
      }
    } else {
      bodyForApiKeyCheck = undefined;
      bodyForPostMessage = input.body;
    }
    return { actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage };
  }

  window.fetch = function(input, optionsArgument) {
    let actualUrl;
    let fetchCallArgs;
    let effectiveOptions = {};
    let bodyForApiKeyCheck;
    let bodyForPostMessage;

    if (typeof input === 'string') {
      ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleStringInput(input, optionsArgument));
    } else if (input instanceof Request) {
      ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleRequestInput(input, optionsArgument));
    } else {
      return originalFetch.apply(window, [input, optionsArgument]);
    }

    effectiveOptions.method = effectiveOptions.method || 'GET';
    if (!effectiveOptions.headers) {
      effectiveOptions.headers = new Headers();
    }


    if (typeof actualUrl === 'string' && googleLlmBaseApiUrls.some((url) => actualUrl.startsWith(url))) {
      let apiKeyIsNull = true;

      const regex = new RegExp("models/([^:]+)");
      const modelNameMatch = actualUrl.match(regex);
      const modelName = modelNameMatch ? modelNameMatch[1] : 'unspecified';


      try {
        const urlObject = new URL(actualUrl);  // Use URL object for robust parsing
        const apiKeyParam = urlObject.searchParams.get('key');
        if (apiKeyParam) {
          apiKeyIsNull = false;
        }
      } catch (e) {
        // Continue checks even if URL parsing fails
      }

      if (apiKeyIsNull && effectiveOptions.headers) {
        const h = new Headers(effectiveOptions.headers);
        const apiKeyHeaderValue = h.get('X-API-Key') || h.get('x-api-key');
        if (apiKeyHeaderValue) {
          apiKeyIsNull = false;
          return originalFetch.apply(window, fetchCallArgs);
        }
      }

      if (apiKeyIsNull && effectiveOptions.method && ['POST', 'PUT', 'PATCH'].includes(effectiveOptions.method.toUpperCase()) && typeof bodyForApiKeyCheck === 'string') {
        try {
          const bodyData = JSON.parse(bodyForApiKeyCheck);
          if (bodyData && bodyData.apiKey) {
            apiKeyIsNull = false;
            return originalFetch.apply(window, fetchCallArgs);
          }
        } catch (e) {
          // Ignore JSON parsing errors
        }
      }

      if(apiKeyIsNull) {
        const promiseId = nextPromiseId++;
        const promise = new Promise((resolve) => {
          pendingFetchResolvers[promiseId] = (resolvedResponse) => {
            delete pendingFetchResolvers[promiseId];
            resolve(resolvedResponse);
          };
        });

        let serializedBodyForPostMessage;
        if (typeof bodyForPostMessage === 'string' || bodyForPostMessage == null) {
            serializedBodyForPostMessage = bodyForPostMessage;
        } else if (bodyForPostMessage instanceof ReadableStream) {
            serializedBodyForPostMessage = null;
        } else {
            try {
                serializedBodyForPostMessage = JSON.stringify(bodyForPostMessage);
            } catch (e) {
                serializedBodyForPostMessage = null;
            }
        }

        const messageOptions = {
            method: effectiveOptions.method,
            headers: Object.fromEntries(new Headers(effectiveOptions.headers).entries()),
            body: serializedBodyForPostMessage
        };

        window.parent.postMessage({
          type: 'requestFetch',
          url: actualUrl,
          modelName: modelName,
          options: messageOptions,
          promiseId: promiseId,
        }, '*');

        return promise;
      }
      return originalFetch.apply(window, fetchCallArgs);
    }
    return originalFetch.apply(window, fetchCallArgs);
  };

  window.addEventListener('message', function(event) {
    if (event.data && event.data.type === 'resolveFetch') {
      const { promiseId, response } = event.data;
      if (pendingFetchResolvers[promiseId]) {
        try {
          const reconstructedResponse = new Response(response.body, {
            status: response.status,
            statusText: response.statusText,
            headers: new Headers(response.headers),
          });
          pendingFetchResolvers[promiseId](reconstructedResponse);
        } catch (error) {
          pendingFetchResolvers[promiseId](new Response(null, { status: 500, statusText: "Interceptor Response Reconstruction Error" }));
        }
      }
    }
  });

}))({"textModelName":"gemini-2.5-flash-preview-09-2025","imageModelName":"imagen-4.0-generate-001","imageEditModelName":"gemini-2.5-flash-image-preview","imageTransformModelName":"gemini-2.5-flash-image-preview","videoModelName":"veo-2.0-generate-001","ttsModelName":"gemini-2.5-flash-preview-tts","deprecatedTextModelNames":["gemini-2.0-flash","gemini-2.5-flash-preview-04-17","gemini-2.5-flash-preview-05-20"],"deprecatedImageModelNames":["imagen-3.0-generate-001","imagen-3.0-generate-002"]})</script><script>(function() {
  const originalConsoleLog = console.log;
  const originalConsoleError = console.error;

    /**
   * Normalizes an error event or a promise rejection reason into a structured error object.
   * @param {*} errorEventOrReason The error object or reason.
   * @return {object} Structured error data { message, name, stack }.
   */
  function getErrorObject(errorEventOrReason) {
    if (errorEventOrReason instanceof Error) {
      return {
        message: errorEventOrReason.message,
        name: errorEventOrReason.name,
        stack: errorEventOrReason.stack,
      };
    }
    // Fallback for non-Error objects.
    try {
      return {
        message: JSON.stringify(errorEventOrReason),
        name: 'UnknownErrorType',
        stack: null,
      };
    } catch (e) {
      return {
        message: String(errorEventOrReason),
        name: 'UnknownErrorTypeNonStringifiable',
        stack: null,
      };
    }
  }

  /**
   * Converts an array of arguments (from log/error) into a single string.
   * Handles Error objects specially to include their message and stack.
   * @param {Array<*>} args - Arguments passed to console methods.
   * @return {string} A string representation of the arguments.
   */
  function stringifyArgs(args) {
    return args
      .map((arg) => {
        if (arg instanceof Error) {
          const {message, stack} = arg;
          return `Error: ${message}${stack ? ('\nStack: ' + stack) : ''}`;
        }
        if (typeof arg === 'object' && arg !== null) {
          try {
            return JSON.stringify(arg);
          } catch (error) {
            return '[Circular Object]';
          }
        } else {
          return String(arg);
        }
      })
      .join(' ');
  }

  console.log = function(...args) {
    const logString = stringifyArgs(args);
    window.parent.postMessage({ type: 'log', message: logString }, '*');
    originalConsoleLog.apply(console, args);
  };

  console.error = function(...args) {
    let errorData;
    if (args.length > 0 && args[0] instanceof Error) {
      const err = args[0];
      // If the first arg is an Error, capture its details.
      errorData = {
        type: 'error',
        source: 'CONSOLE_ERROR',
        ...getErrorObject(err),
        rawArgsString: stringifyArgs(args.slice(1)),
        timestamp: new Date().toISOString(),
      };
    } else {
      // If not an Error object, treat all args as a general error message.
      errorData = {
        type: 'error',
        source: 'CONSOLE_ERROR',
        message: stringifyArgs(args),
        name: 'ConsoleLoggedError',
        stack: null,
        timestamp: new Date().toISOString(),
      };
    }
    window.parent.postMessage(errorData, '*');
    originalConsoleError.apply(console, args);
  };

  // Listen for global unhandled synchronous errors.
  window.addEventListener('error', function(event) {
    const errorDetails = event.error ? getErrorObject(event.error) : {
      message: event.message,
      name: 'GlobalError',
      stack: null,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
    };

    window.parent.postMessage({
      type: 'error',
      source: 'global',
      ...errorDetails,
      message: errorDetails.message || event.message,
      timestamp: new Date().toISOString(),
    }, '*');
  });

  // Listen for unhandled promise rejections (asynchronous errors).
  window.addEventListener('unhandledrejection', function(event) {
    const errorDetails = getErrorObject(event.reason);

    window.parent.postMessage({
      type: 'error',
      source: 'unhandledrejection',
      ...errorDetails,
      message: errorDetails.message || 'Unhandled Promise Rejection',
      timestamp: new Date().toISOString(),
    }, '*');
  });

})();</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ghetto-Hub R/W</title>
    <style>
        /* POTATO MODE v2.0 */
        body { 
            background-color: #000; 
            color: #ccc; 
            font-family: monospace; 
            font-size: 14px; 
            margin: 0; padding: 5px; 
        }
        
        /* HEADER & NAV */
        #header { border-bottom: 1px solid #333; padding-bottom: 5px; margin-bottom: 5px; }
        .crumb { color: #888; font-size: 12px; }

        /* BUTTONS */
        button { 
            background: #222; color: #fff; border: 1px solid #555; 
            padding: 8px; width: 100%; margin-bottom: 5px; cursor: pointer;
            text-transform: uppercase; font-weight: bold;
        }
        button:focus, .item:focus { 
            background: #fff; color: #000; border: 2px solid #0f0; outline: none; 
        }
        
        /* SPECIAL ACTIONS */
        .btn-upload { background: #004D40; color: #00e676; border-color: #00695c; }
        .btn-overwrite { background: #b71c1c; color: #ff8a80; border-color: #d32f2f; }
        .btn-save { background: #0d47a1; color: #82b1ff; border-color: #1565c0; }

        /* LIST ITEMS */
        .item { 
            display: block; padding: 10px 5px; 
            border-bottom: 1px solid #222; 
            text-decoration: none; cursor: pointer;
        }
        .type-dir { color: #d4d400; } 
        .type-file { color: #0f0; } 
        
        /* VIEWER/EDITOR */
        #editorContainer { display: none; }
        #viewer { display: none; white-space: pre-wrap; word-wrap: break-word; background: #111; padding: 5px; border: 1px solid #333; font-size: 12px;}
        #fileEditor {
            width: 100%; 
            height: 300px; 
            background: #000; 
            color: #fff; 
            border: 1px solid #333; 
            padding: 5px; 
            margin-bottom: 5px; 
            font-size: 12px;
            resize: vertical;
        }
        
        /* INPUTS */
        input[type="text"] { background: #000; color: #fff; border: 1px solid #333; width: 100%; padding: 5px; margin-bottom: 5px; }
        .hidden-input { display: none; }
    </style>
</head>
<body>

    <!-- SETUP SCREEN -->
    <div id="setup">
        <h3>GH MASTER LOGIN</h3>
        <input type="text" id="ghToken" placeholder="Paste Token (ghp_...)">
        
        <!-- NEW: File Upload for Token -->
        <div style="display:grid; grid-template-columns: 1fr 2fr; gap:5px; margin-bottom: 5px;">
            <input type="file" id="tokenUploader" class="hidden-input" accept=".txt" onchange="handleTokenFileSelect(this)">
            <button onclick="document.getElementById('tokenUploader').click()" class="btn-upload" style="margin-bottom: 0;">[+] UPLOAD TOKEN</button>
            <div style="font-size:10px; color:#666; grid-column: 1 / span 2; text-align: center;">(Token from file)</div>
        </div>

        <button onclick="saveAndStart()">LOGIN</button>
        <div id="setupStatus" style="color:cyan; font-size:10px; min-height:15px; margin-top: 5px;"></div>
        <div style="font-size:10px; color:#666;">(Saved to localStorage)</div>
    </div>

    <!-- MAIN APP -->
    <div id="app" style="display:none;">
        <div id="header">
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
                <button onclick="goHome()">[HOME]</button> 
                <button onclick="goBack()">[BACK]</button>
            </div>
            <div id="breadcrumbs" class="crumb">...</div>
            <div id="status" style="color:cyan; font-size:10px; min-height:15px;"></div>
        </div>

        <!-- ACTION BAR (Dynamic - Now handles both buttons via JS control) -->
        <div id="actionBar" style="display:grid; grid-template-columns: 1fr 1fr; gap:5px; margin-bottom: 5px;">
            <!-- Hidden input for file handling -->
            <input type="file" id="uploadInput" class="hidden-input" onchange="handleFileSelect(this)">
            
            <!-- Dynamic Inject/Upload Button (Left/Full Width) -->
            <button id="btnInject" class="btn-overwrite" onclick="triggerUpload()"></button>
            
            <!-- Commit Button (Right) - Moved here -->
            <button id="btnSave" class="btn-save" style="display:none;" onclick="saveFileChanges()">[üíæ] COMMIT CHANGES</button>
        </div>

        <div id="list"></div>
        
        <!-- EDITOR CONTAINER (Only contains the textarea now) -->
        <div id="editorContainer">
            <textarea id="fileEditor"></textarea>
        </div>
        
        <pre id="viewer"></pre>
    </div>

    <!-- DOWNLOAD LINK (FOOTER) -->
    <div id="downloadFooter" style="margin-top: 15px; text-align: center; border-top: 1px solid #333; padding-top: 5px;">
        <a href="#" id="downloadLink" style="color: #61afef; text-decoration: none; font-size: 10px;" download="ghetto_hub_rw.html">
            [Download This Page]
        </a>
    </div>

    <script>
        // === STATE ===
        let currentOwner = "";
        let currentRepo = "";
        let currentPath = "";
        let currentFileSha = null; // Needed to overwrite files
        let currentView = "setup"; // setup, repos, tree, blob
        let historyStack = [];

        // === BASE64/UNICODE HELPERS ===
        /**
         * Safely Base64 encodes a string containing Unicode characters (UTF-8 safe).
         * Used for sending file content to GitHub.
         */
        function b64EncodeUnicode(str) {
            // Encode the string as UTF-8, then map the resulting bytes to single-byte characters (unescape),
            // which btoa can handle.
            return btoa(unescape(encodeURIComponent(str)));
        }

        /**
         * Safely Base64 decodes a string containing Unicode characters (UTF-8 safe).
         * Used for reading file content from GitHub.
         */
        function b64DecodeUnicode(str) {
            // Decode from base64, then escape the characters to turn them into %XX codes, 
            // and finally decode URI to convert the %XX codes back to UTF-8.
            return decodeURIComponent(escape(atob(str)));
        }

        // === API HELPER ===
        async function api(endpoint, method = 'GET', body = null) {
            const token = localStorage.getItem('gh_token');
            const url = `https://api.github.com${endpoint}`;
            
            const headers = {
                "Authorization": `token ${token}`,
                "Accept": "application/vnd.github.v3+json",
                "Content-Type": "application/json"
            };

            const config = {
                method,
                headers,
                body: body ? JSON.stringify(body) : undefined
            };

            const response = await fetch(url, config);
            if (!response.ok) {
                const errorBody = await response.json();
                // Throw an error that includes the actual GitHub message
                throw new Error(errorBody.message || `GitHub API Error: ${response.status}`);
            }
            
            // Handle 204 No Content for delete/update operations
            if (response.status === 204) return null; 

            // Only parse JSON if there is content
            if (response.headers.get("content-length") === "0") return null;
            return response.json();
        }

        // === UI HELPERS ===
        function updateUI(crumb) {
            document.getElementById('breadcrumbs').innerText = `Path: ${crumb}`;
            document.getElementById('list').style.display = currentView === 'tree' || currentView === 'repos' ? 'block' : 'none';
            document.getElementById('viewer').style.display = 'none'; // Viewer is now legacy
            document.getElementById('editorContainer').style.display = currentView === 'blob' ? 'block' : 'none';

            // Action bar controls: Dynamic Inject/Upload and Commit Buttons
            const actionBar = document.getElementById('actionBar'); 
            const btnInject = document.getElementById('btnInject');
            const btnSave = document.getElementById('btnSave'); 

            if (currentView === 'tree') {
                // In tree view, the upload button should span full width, and the commit button is hidden
                actionBar.style.gridTemplateColumns = '1fr'; 
                
                btnInject.style.display = 'block';
                btnInject.innerText = "[+] UPLOAD NEW FILE (FEATURE NOT IMPLEMENTED)";
                btnInject.classList.remove('btn-overwrite');
                btnInject.classList.add('btn-upload');
                
                btnSave.style.display = 'none'; 

            } else if (currentView === 'blob') {
                // In blob view, both buttons appear side-by-side
                actionBar.style.gridTemplateColumns = '1fr 1fr'; 
                
                btnInject.style.display = 'block';
                btnInject.innerText = "[üíæ] FILE-TO-EDITOR INJECT";
                btnInject.classList.remove('btn-upload');
                btnInject.classList.add('btn-overwrite');
                
                btnSave.style.display = 'block'; 
                
            } else { // repos/setup
                actionBar.style.gridTemplateColumns = '1fr';
                btnInject.style.display = 'none';
                btnSave.style.display = 'none';
            }
        }

        function createItem(parent, text, className, onClick) {
            const a = document.createElement('a');
            a.className = `item ${className}`;
            a.href = "#";
            a.innerText = text;
            a.onclick = (e) => { e.preventDefault(); onClick(); };
            parent.appendChild(a);
        }
        
        /**
         * Generates a blob URL for the entire page HTML for download.
         */
        function setupDownloadLink() {
            try {
                const htmlContent = document.documentElement.outerHTML;
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);

                const link = document.getElementById('downloadLink');
                link.href = url;
            } catch (e) {
                console.error("Failed to setup download link:", e);
                const link = document.getElementById('downloadLink');
                link.innerText = "Download Error";
                link.style.color = 'red';
            }
        }


        // === INIT ===
        window.onload = function() {
            setupDownloadLink(); // Set up the download link immediately
            if(localStorage.getItem('gh_token')) {
                document.getElementById('ghToken').value = localStorage.getItem('gh_token');
                startApp();
            }
        }

        function saveAndStart() {
            const token = document.getElementById('ghToken').value;
            if (!token.trim()) {
                 document.getElementById('setupStatus').innerText = "ERROR: Token field is empty. Try uploading a file with the token.";
                 return;
            }
            localStorage.setItem('gh_token', token);
            startApp();
        }

        function startApp() {
            document.getElementById('setup').style.display = 'none';
            document.getElementById('app').style.display = 'block';
            loadRepos();
        }

        // Modified to work in the main app's status bar
        function setStatus(msg) { 
            const statusDiv = document.getElementById('status');
            if (statusDiv) {
                statusDiv.innerText = msg;
            }
        }
        
        // Setup status is handled separately by handleTokenFileSelect


        // === NAVIGATION ===
        function goHome() {
            historyStack = [];
            loadRepos();
        }

        function goBack() {
            if(historyStack.length === 0) return goHome();
            const prev = historyStack.pop();
            if(prev.view === 'repos') loadRepos();
            else if (prev.view === 'tree') loadTree(prev.owner, prev.repo, prev.path, false);
            else if (prev.view === 'blob') { // If backing out of editor, go back to tree view
                const treeState = historyStack.pop(); // Get state before blob
                if (treeState) loadTree(treeState.owner, treeState.repo, treeState.path, false);
                else goHome();
            }
        }

        // === CORE VIEWS ===
        
        // 1. LIST REPOS
        async function loadRepos() {
            currentView = "repos";
            currentOwner = ""; currentRepo = ""; currentPath = "";
            updateUI("Home"); 
            
            const list = document.getElementById('list');
            list.innerHTML = "Loading Repos...";

            try {
                const repos = await api('/user/repos?sort=updated&per_page=30');
                list.innerHTML = "";
                repos.forEach(repo => {
                    createItem(list, `ÓÅûÂàÄ ${repo.name}`, 'type-dir', () => {
                        historyStack.push({view:'repos'});
                        loadTree(repo.owner.login, repo.name, "");
                    });
                });
                setStatus("Ready.");
            } catch(e) { 
                list.innerHTML = `Error loading repos: ${e.message}`; 
                setStatus("Login failed or no repos found.");
            }
        }

        // 2. LIST FILES (TREE)
        async function loadTree(owner, repo, path, pushHistory = true) {
            if(pushHistory && currentRepo && currentView !== 'repos') historyStack.push({view:'tree', owner:currentOwner, repo:currentRepo, path:currentPath});
            
            currentOwner = owner; currentRepo = repo; currentPath = path;
            currentView = "tree";
            
            updateUI(`${repo}/${path}`); 

            const list = document.getElementById('list');
            list.innerHTML = "Loading...";

            try {
                const data = await api(`/repos/${owner}/${repo}/contents/${path}`);
                list.innerHTML = "";
                const items = Array.isArray(data) ? data : [data];
                
                items.sort((a, b) => (a.type === b.type ? 0 : a.type === 'dir' ? -1 : 1));

                items.forEach(item => {
                    if (item.type === 'dir') {
                        createItem(list, `ÓÅûÂàÄ ${item.name}`, 'type-dir', () => loadTree(owner, repo, item.path));
                    } else {
                        createItem(list, `ÓÅûÂ°ò ${item.name}`, 'type-file', () => loadFile(item.url, item.path, item.sha));
                    }
                });
                setStatus(`Loaded ${items.length} items in ${path || '/'}.`);
            } catch(e) { 
                list.innerHTML = "Empty folder or Error fetching files."; 
                setStatus(`ERROR: ${e.message}`);
            }
        }

        // 3. VIEW FILE (BLOB/EDITOR)
        async function loadFile(url, path, sha) {
            historyStack.push({view:'tree', owner:currentOwner, repo:currentRepo, path:currentPath});
            
            currentPath = path; 
            currentFileSha = sha; 
            currentView = "blob";

            updateUI(path);

            const editor = document.getElementById('fileEditor');
            editor.value = "";
            setStatus("Fetching file content for editing...");

            try {
                const res = await fetch(url, { headers: { "Authorization": `token ${localStorage.getItem('gh_token')}` } });
                const data = await res.json();

                if (data.content && data.encoding === 'base64') {
                    // Base64 decode content and put it in the editor, safely decoding Unicode
                    editor.value = b64DecodeUnicode(data.content);
                    setStatus(`File ${path} loaded. Ready to edit or inject content.`);
                } else {
                    editor.value = "File content could not be decoded. Maybe it's binary?";
                    setStatus("WARNING: Could not decode file content.");
                }

            } catch(e) {
                editor.value = `Error loading file: ${e.message}`;
                setStatus(`FATAL ERROR: ${e.message}`);
            }
        }

        // === TOKEN UPLOAD LOGIC ===

        /**
         * Reads the uploaded file and injects its content into the TOKEN field.
         */
        function handleTokenFileSelect(input) {
            const statusDiv = document.getElementById('setupStatus');
            statusDiv.innerText = "Reading token from file...";
            const file = input.files[0];
            if (!file) {
                statusDiv.innerText = "No file selected for token.";
                return;
            }

            try {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const tokenInput = document.getElementById('ghToken');
                    // Trim to prevent reading leading/trailing newlines from the file
                    tokenInput.value = e.target.result.trim(); 
                    statusDiv.innerText = "Token loaded into input. Now LOGIN.";
                    input.value = ''; // Clear input
                };
                reader.onerror = () => {
                    statusDiv.innerText = "ERROR: Could not read token file.";
                    input.value = '';
                };
                reader.readAsText(file);
            } catch (e) {
                statusDiv.innerText = "FATAL ERROR during token file read.";
            }
        }


        // === FILE ACTION LOGIC (CONTENT INJECTION) ===

        function triggerUpload() {
            // Only trigger file select if we are in blob view and can inject content
            if (currentView === 'blob') {
                 document.getElementById('uploadInput').click();
            } else {
                // Placeholder warning when clicking the button in directory view
                setStatus("New file creation not yet supported. Select a file first to use the injection feature.");
            }
        }
        
        /**
         * Reads the uploaded file and injects its content into the editor.
         */
        async function handleFileSelect(input) {
            setStatus("Reading file from your prehistoric device...");
            const file = input.files[0];
            if (!file) {
                setStatus("No file selected.");
                return;
            }

            try {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const editor = document.getElementById('fileEditor');
                    editor.value = e.target.result;
                    setStatus("File content loaded into editor. Now COMMIT CHANGES.");
                    input.value = ''; // Clear input
                };
                reader.onerror = () => {
                    setStatus("ERROR: Could not read file from your upload.");
                    input.value = '';
                };
                reader.readAsText(file);
            } catch (e) {
                setStatus("FATAL ERROR during file read process.");
            }
        }

        /**
         * Commits the edited content back to GitHub.
         */
        async function saveFileChanges() {
            setStatus("Committing changes... This is gonna hurt.");
            
            const editor = document.getElementById('fileEditor');
            const content = editor.value;
            // Use Unicode-safe encoding
            const encodedContent = b64EncodeUnicode(content); 

            const commitBody = {
                message: `Update ${currentPath} via Ghetto-Hub R/W (flip phone edition)`,
                content: encodedContent,
                sha: currentFileSha // CRITICAL: required to update an existing file
            };

            try {
                const url = `/repos/${currentOwner}/${currentRepo}/contents/${currentPath}`;
                const result = await api(url, 'PUT', commitBody);
                
                // Update SHA for subsequent saves
                currentFileSha = result.content.sha; 
                setStatus(`SUCCESS: File saved! New SHA: ${currentFileSha.substring(0, 7)}`);

            } catch (e) {
                // Log the full error object for better debugging
                console.error("GitHub Commit Error:", e);
                setStatus(`COMMIT FAILED: ${e.message}. CHECK CONSOLE FOR DETAILS.`);
            }
        }

        // Initialize global variables (required boilerplate, even if not used)
        const __app_id = "default-app-id";
        const __firebase_config = '{}';
        const __initial_auth_token = "";
    </script>

</body></html>